from pyspark.sql import functions as F

# ============================================================
# CONFIGURATION
# ============================================================

base_path = "/Volumes/workspace/default/hu_de_data/"

# Load cleaned or repaired tables
orders = spark.read.format("delta").load(os.path.join(base_path, "orders_repaired.delta"))
items = spark.read.format("delta").load(os.path.join(base_path, "order_items_with_seller_30d_on_time.delta"))
customers = spark.read.format("delta").load(os.path.join(base_path, "olist_customers_dataset_cleaned.delta"))
products = spark.read.format("delta").load(os.path.join(base_path, "olist_products_dataset_cleaned.delta"))
payments = spark.read.format("delta").load(os.path.join(base_path, "olist_order_payments_dataset_cleaned.delta"))

# ============================================================
# 3.1Ô∏è‚É£ BUILD FACT TABLE
# ============================================================

fact_orders = (
    orders.join(items, "order_id", "left")
          .join(customers, "customer_id", "left")
          .join(products, "product_id", "left")
          .join(payments, "order_id", "left")
          .withColumn("revenue", F.col("price") + F.col("freight_value"))
          .withColumn("delivery_delay_days", F.datediff(F.col("delivered_ts_repaired"), F.col("order_estimated_delivery_date")))
          .withColumn("order_month", F.date_trunc("month", F.col("purchase_ts_repaired")))
)

# Save fact table
fact_orders.write.mode("overwrite").format("delta").save(os.path.join(base_path, "fact_orders.delta"))
fact_orders.createOrReplaceTempView("fact_orders")
print("‚úÖ Fact table created successfully.")

# ============================================================
# 3.2Ô∏è‚É£ SELLER MONTHLY FUNNEL (P‚ÜíA‚ÜíD conversion)
# ============================================================

funnel = spark.sql("""
SELECT 
    seller_id,
    date_trunc('month', purchase_ts_repaired) AS month,
    COUNT(DISTINCT CASE WHEN purchase_ts_repaired IS NOT NULL THEN order_id END) AS orders_P,
    COUNT(DISTINCT CASE WHEN approved_ts_repaired IS NOT NULL THEN order_id END) AS orders_A,
    COUNT(DISTINCT CASE WHEN delivered_ts_repaired IS NOT NULL THEN order_id END) AS orders_D,
    ROUND(
        COUNT(DISTINCT CASE WHEN approved_ts_repaired IS NOT NULL THEN order_id END)
        / NULLIF(COUNT(DISTINCT CASE WHEN purchase_ts_repaired IS NOT NULL THEN order_id END),0),3
    ) AS P_to_A_rate,
    ROUND(
        COUNT(DISTINCT CASE WHEN delivered_ts_repaired IS NOT NULL THEN order_id END)
        / NULLIF(COUNT(DISTINCT CASE WHEN approved_ts_repaired IS NOT NULL THEN order_id END),0),3
    ) AS A_to_D_rate
FROM fact_orders
GROUP BY seller_id, month
""")

funnel.write.mode("overwrite").format("delta").save(os.path.join(base_path, "seller_monthly_funnel_rates.delta"))
funnel.createOrReplaceTempView("seller_monthly_funnel_rates")
print("‚úÖ Seller funnel metrics computed and saved.")

# ============================================================
# 3.3Ô∏è‚É£ SELLER REVENUE SHARE BY CATEGORY (Top 5 + OTHERS)
# ============================================================

items_prod = (
    items.join(products, "product_id", "left")
         .select("order_id", "order_item_id", "seller_id", "price", "freight_value", "product_category_name")
         .withColumn("revenue", F.coalesce(F.col("price"), F.lit(0)) + F.coalesce(F.col("freight_value"), F.lit(0)))
)

# Revenue per seller-category
seller_cat_rev = (
    items_prod.groupBy("seller_id", "product_category_name")
              .agg(F.sum("revenue").alias("category_revenue"))
)

# Rank categories per seller
from pyspark.sql.window import Window
w_seller = Window.partitionBy("seller_id").orderBy(F.col("category_revenue").desc())
seller_cat_ranked = seller_cat_rev.withColumn("rank", F.row_number().over(w_seller))

# Top 5 categories and aggregate others
top5 = seller_cat_ranked.filter(F.col("rank") <= 5)
others = (
    seller_cat_ranked.filter(F.col("rank") > 5)
                     .groupBy("seller_id")
                     .agg(F.sum("category_revenue").alias("category_revenue"))
                     .withColumn("product_category_name", F.lit("OTHERS"))
)

seller_cat_final = top5.select("seller_id", "product_category_name", "category_revenue").unionByName(
    others.select("seller_id", "product_category_name", "category_revenue")
)

# Compute revenue share
seller_total = seller_cat_final.groupBy("seller_id").agg(F.sum("category_revenue").alias("seller_total_rev"))
seller_cat_final = (
    seller_cat_final.join(seller_total, "seller_id", "left")
                    .withColumn("revenue_share", F.col("category_revenue") / F.col("seller_total_rev"))
)

seller_cat_final.write.mode("overwrite").format("delta").save(os.path.join(base_path, "seller_category_revenue_share.delta"))
seller_cat_final.createOrReplaceTempView("seller_category_revenue_share")
print("‚úÖ Seller revenue share by category computed and saved.")

# ============================================================
# 3.4Ô∏è‚É£ PAYMENT METHOD SHARE
# ============================================================

payment_share = (
    payments.groupBy("payment_type")
            .agg(F.round(F.sum("payment_value"), 2).alias("total_payment"))
            .withColumn("payment_share_pct", F.round(F.col("total_payment") / F.sum("total_payment").over(Window()), 3))
)

payment_share.write.mode("overwrite").format("delta").save(os.path.join(base_path, "payment_method_share.delta"))
payment_share.createOrReplaceTempView("payment_method_share")
print("‚úÖ Payment method share computed and saved.")

# ============================================================
# 3.5Ô∏è‚É£ DELIVERY DELAY STATS PER CATEGORY
# ============================================================

delay_stats = (
    fact_orders.groupBy("product_category_name")
               .agg(
                    F.mean("delivery_delay_days").alias("avg_delay"),
                    F.percentile_approx("delivery_delay_days", 0.5).alias("median_delay"),
                    F.stddev("delivery_delay_days").alias("std_delay")
                )
)

delay_stats.write.mode("overwrite").format("delta").save(os.path.join(base_path, "delivery_delay_stats.delta"))
delay_stats.createOrReplaceTempView("delivery_delay_stats")
print("‚úÖ Delivery delay stats computed and saved.")

print("\nüéØ Step 3 completed: fact table + KPIs successfully built.")
